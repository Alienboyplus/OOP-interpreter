### 解释器模式

1：

今天我要介绍的是解释器模式，解释器模式是一种定义某种语言文法，并且建立一个解释器来解释该语言中句子的模式。

2：

接下来，我会从模式的动机与定义、模式结构与分析、模式实例与解析以及模式效果与应用四个方面去介绍。

3：

首先是模式的动机，我们可以从这个例子去理解。如图所示是一个加减法程序，我们希望在程序中进行多样式的加减法运算，具体而言，在输入框中输入相应的表达式，经过计算后获取最终结果。

4：

值得注意的是，由于我们输入表达式的是一串字符串，即“1 + 2 + 3 – 4 + 1”，而Java语言是无法直接理解或解释这样的字符串的。为了在实际应用中解决这样的问题，我们需要定义一套文法规则来实现对这些语句的解释，即设计一个自定义语言，通过语言去解释一个个相应的句子。

5：

所以，以下就是解释器模式的定义：定义一个语言的文法，并且建立一个解释器来解释该语言中的句子。这里的语言指的是使用规定格式和语法的代码，解释器模式是一种类行为型模式。

这里可以提一下，行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。在行为模式的11种模式中，除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型模式。

6：

解释器模式是一种使用频率相对较低但学习难度相对较大的设计模式，用于描述如何使用面向对象语言构成一个简单的语言解释器。掌握解释器模式，就能够加深对面向对象思想的理解，并且理解编程语言中文法规则的解释过程

7：

解释器模式的结构如图所示，由四个角色构成，分别是抽象表达式、终结符表达式、环境类和非终结符表达式。它们之间的关系是：Client依赖抽象表达式和环境类，抽象表达式依赖环境类，终结符表达式和非终结符表达式是抽象表达式的子类。抽象表达式和非终结符表达式之间也存在着聚合的关系。以上的这些关系需要我们整合到文法规则中进行使用。

8：

现在我们可以通过一个例子来理解文法规则的制定。这个例子来自于前面的多项式，我们可以使用如下文法规则来定义。

该文法规则包含三条语句，符号“::=”表示“定义为”的意思，所以第一条语句的含义为，一个expression由一个value或一个operation构成；第二条语句的含义为，一个operation由两个expression相加或相减构成；第三条语句为，一个value由一个整数值构成。通过比较第一和第二条表达式，我们也可以理解抽象表达式和非终结符表达式之间的聚合关系。

9：

除了使用文法规则来定义一个语言，在解释器模式中还可以通过一种称之为抽象语法树的图形方式来直观地表示语言的构成，如图所示。在这棵树中，我们可以很清楚地识别出终结符和非终结符这两种表达式，value是终结符表达式，它的组成元素是最基本的语言单位，不能再进行分解。operation是非终结符表达式，它的组成元素仍然可以是表达式，可以进一步分解。

10：

那么根据上述的定义，我们可以写出终结符表达式的示例代码，其中context的含义会在后文介绍。

11：

非终结符表达式相比之下多了两部分，一部分是需要定义left和right，即进行加减时的两个数；另一部分是会递归调用每一个组成部分的interpret()方法，即实现非终结符的功能。

12：

环境类又称为上下文类，它用于存储解释器之外的一些全局信息，通常它临时存储了需要解释的语句，前面的终结符和非终结符表达式中可以使用context类存储的语句，用于在执行具体的解释操作时从中获取相关信息。

我们可以在Context对象中存储和访问表达式解释器的状态，向表达式解释器提供一些全局的、公共的数据，此外还可以在Context中增加一些所有表达式解释器都共有的功能，减轻解释器的职责。

13：

那么环境类的代码其实就是只包含了存值和取值两个操作，并且通过HashMap来实现。

14：

在了解了解释器模式的结构和部分角色的含义后，我们通过一个实例来更深入了解一下，现需要构造一个语言解释器，使得系统可以执行整数间的乘、除和求模运算。例如：用户输入表达式“3 * 4 / 2 % 4”，输出结果为2。使用解释器模式实现该功能。

15：

首先，根据任务要求，我们可以构建出类图。首先是节点类，节点类分为值节点ValueNode和符号节点SymbolNode两类，符号节点又是一个抽象类，包含乘除和取余三类符号。然后是计算器类，用户通过构建某种特定文法的计算器来完成计算任务。

16：

其次，我们可以根据任务要求绘制出这个表达式的抽象语法树。然后是每个角色相关的代码。

17：

至于解释器模式在开源项目中的应用，他可被用到编译器、运算表达式和正则表达式的计算中。我这里介绍的是Springboot用到的ExpressionParser，他的功能是根据自己定义的一套语法规则，计算用户输入的表达式结果：

```java
import org.springframework.expression.Expression;
import org.springframework.expression.ExpressionParser;
import org.springframework.expression.spel.standard.SpelExpressionParser;
public class Test {
    public static void main(String[] args) {
        ExpressionParser parser = new SpelExpressionParser();
        Expression expression = parser.parseExpression("100*2+400*1+66");
        int result = (Integer) expression.getValue();
        System.out.println("计算结果是：" + result);
    }
}
///输出结果：666
```

18：



其中，抽象表达式声明了抽象的解释操作，它是所有终结符表达式和非终结符表达式的公共父类。

终结符表达式是抽象表达式的子类，它实现了与文法中的终结符相关联的解释操作，在句子中的每一个终结符都是该类的一个实例。通常在一个解释器模式中只有少数几个终结符表达式类，它们的实例可以通过非终结符表达式组成较为复杂的句子。

非终结符表达式也是抽象表达式的子类，它实现了文法中非终结符的解释操作，由于在非终结符表达式中可以包含终结符表达式，也可以继续包含非终结符表达式，因此其解释操作一般通过递归的方式来完成。

环境类又称为上下文类，它用于存储解释器之外的一些全局信息，通常它临时存储了需要解释的语句。

---

Java代码：

我们来看一下一个多项式加减法的demo，接下来我会一个个介绍相应的类及代码。

首先是抽象类expression
